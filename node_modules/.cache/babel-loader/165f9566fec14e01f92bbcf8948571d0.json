{"ast":null,"code":"/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\nimport { types } from 'util';\nimport http from 'http';\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ? http.validateHeaderName : name => {\n  if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_HTTP_TOKEN'\n    });\n    throw error;\n  }\n};\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ? http.validateHeaderValue : (name, value) => {\n  if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n    const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_CHAR'\n    });\n    throw error;\n  }\n};\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\n\nexport default class Headers extends URLSearchParams {\n  /**\n   * Headers class\n   *\n   * @constructor\n   * @param {HeadersInit} [init] - Response headers\n   */\n  constructor(init) {\n    // Validate and normalize init object in [name, value(s)][]\n\n    /** @type {string[][]} */\n    let result = [];\n\n    if (init instanceof Headers) {\n      const raw = init.raw();\n\n      for (const [name, values] of Object.entries(raw)) {\n        result.push(...values.map(value => [name, value]));\n      }\n    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq\n      // No op\n    } else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n      const method = init[Symbol.iterator]; // eslint-disable-next-line no-eq-null, eqeqeq\n\n      if (method == null) {\n        // Record<ByteString, ByteString>\n        result.push(...Object.entries(init));\n      } else {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // Sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        result = [...init].map(pair => {\n          if (typeof pair !== 'object' || types.isBoxedPrimitive(pair)) {\n            throw new TypeError('Each header pair must be an iterable object');\n          }\n\n          return [...pair];\n        }).map(pair => {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          return [...pair];\n        });\n      }\n    } else {\n      throw new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n    } // Validate and lowercase\n\n\n    result = result.length > 0 ? result.map(([name, value]) => {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return [String(name).toLowerCase(), String(value)];\n    }) : undefined;\n    super(result); // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n    // eslint-disable-next-line no-constructor-return\n\n    return new Proxy(this, {\n      get(target, p, receiver) {\n        switch (p) {\n          case 'append':\n          case 'set':\n            return (name, value) => {\n              validateHeaderName(name);\n              validateHeaderValue(name, String(value));\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));\n            };\n\n          case 'delete':\n          case 'has':\n          case 'getAll':\n            return name => {\n              validateHeaderName(name);\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n            };\n\n          case 'keys':\n            return () => {\n              target.sort();\n              return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n            };\n\n          default:\n            return Reflect.get(target, p, receiver);\n        }\n      }\n      /* c8 ignore next */\n\n\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  toString() {\n    return Object.prototype.toString.call(this);\n  }\n\n  get(name) {\n    const values = this.getAll(name);\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    let value = values.join(', ');\n\n    if (/^content-encoding$/i.test(name)) {\n      value = value.toLowerCase();\n    }\n\n    return value;\n  }\n\n  forEach(callback, thisArg = undefined) {\n    for (const name of this.keys()) {\n      Reflect.apply(callback, thisArg, [this.get(name), name, this]);\n    }\n  }\n\n  *values() {\n    for (const name of this.keys()) {\n      yield this.get(name);\n    }\n  }\n  /**\n   * @type {() => IterableIterator<[string, string]>}\n   */\n\n\n  *entries() {\n    for (const name of this.keys()) {\n      yield [name, this.get(name)];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Node-fetch non-spec method\n   * returning all headers and their values as array\n   * @returns {Record<string, string[]>}\n   */\n\n\n  raw() {\n    return [...this.keys()].reduce((result, key) => {\n      result[key] = this.getAll(key);\n      return result;\n    }, {});\n  }\n  /**\n   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return [...this.keys()].reduce((result, key) => {\n      const values = this.getAll(key); // Http.request() only supports string as Host header.\n      // This hack makes specifying custom Host header possible.\n\n      if (key === 'host') {\n        result[key] = values[0];\n      } else {\n        result[key] = values.length > 1 ? values : values[0];\n      }\n\n      return result;\n    }, {});\n  }\n\n}\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\n\nObject.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n  result[property] = {\n    enumerable: true\n  };\n  return result;\n}, {}));\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\n\nexport function fromRawHeaders(headers = []) {\n  return new Headers(headers // Split into pairs\n  .reduce((result, value, index, array) => {\n    if (index % 2 === 0) {\n      result.push(array.slice(index, index + 2));\n    }\n\n    return result;\n  }, []).filter(([name, value]) => {\n    try {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return true;\n    } catch {\n      return false;\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/vidmantasburba/Desktop/FrontEnd/frontend_oxylabs/testio/node_modules/node-fetch/src/headers.js"],"names":["types","http","validateHeaderName","name","test","error","TypeError","Object","defineProperty","value","validateHeaderValue","Headers","URLSearchParams","constructor","init","result","raw","values","entries","push","map","isBoxedPrimitive","method","Symbol","iterator","pair","length","String","toLowerCase","undefined","Proxy","get","target","p","receiver","prototype","call","sort","Set","keys","Reflect","toStringTag","toString","getAll","join","forEach","callback","thisArg","apply","reduce","key","for","defineProperties","property","enumerable","fromRawHeaders","headers","index","array","slice","filter"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,SAAQA,KAAR,QAAoB,MAApB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,MAAMC,kBAAkB,GAAG,OAAOD,IAAI,CAACC,kBAAZ,KAAmC,UAAnC,GAC1BD,IAAI,CAACC,kBADqB,GAE1BC,IAAI,IAAI;AACP,MAAI,CAAC,0BAA0BC,IAA1B,CAA+BD,IAA/B,CAAL,EAA2C;AAC1C,UAAME,KAAK,GAAG,IAAIC,SAAJ,CAAe,2CAA0CH,IAAK,GAA9D,CAAd;AACAI,IAAAA,MAAM,CAACC,cAAP,CAAsBH,KAAtB,EAA6B,MAA7B,EAAqC;AAACI,MAAAA,KAAK,EAAE;AAAR,KAArC;AACA,UAAMJ,KAAN;AACA;AACD,CARF;AAUA,MAAMK,mBAAmB,GAAG,OAAOT,IAAI,CAACS,mBAAZ,KAAoC,UAApC,GAC3BT,IAAI,CAACS,mBADsB,GAE3B,CAACP,IAAD,EAAOM,KAAP,KAAiB;AAChB,MAAI,kCAAkCL,IAAlC,CAAuCK,KAAvC,CAAJ,EAAmD;AAClD,UAAMJ,KAAK,GAAG,IAAIC,SAAJ,CAAe,yCAAwCH,IAAK,IAA5D,CAAd;AACAI,IAAAA,MAAM,CAACC,cAAP,CAAsBH,KAAtB,EAA6B,MAA7B,EAAqC;AAACI,MAAAA,KAAK,EAAE;AAAR,KAArC;AACA,UAAMJ,KAAN;AACA;AACD,CARF;AAUA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMM,OAAN,SAAsBC,eAAtB,CAAsC;AACpD;AACD;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACjB;;AACA;AACA,QAAIC,MAAM,GAAG,EAAb;;AACA,QAAID,IAAI,YAAYH,OAApB,EAA6B;AAC5B,YAAMK,GAAG,GAAGF,IAAI,CAACE,GAAL,EAAZ;;AACA,WAAK,MAAM,CAACb,IAAD,EAAOc,MAAP,CAAX,IAA6BV,MAAM,CAACW,OAAP,CAAeF,GAAf,CAA7B,EAAkD;AACjDD,QAAAA,MAAM,CAACI,IAAP,CAAY,GAAGF,MAAM,CAACG,GAAP,CAAWX,KAAK,IAAI,CAACN,IAAD,EAAOM,KAAP,CAApB,CAAf;AACA;AACD,KALD,MAKO,IAAIK,IAAI,IAAI,IAAZ,EAAkB,CAAE;AAC1B;AACA,KAFM,MAEA,IAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,CAACd,KAAK,CAACqB,gBAAN,CAAuBP,IAAvB,CAAjC,EAA+D;AACrE,YAAMQ,MAAM,GAAGR,IAAI,CAACS,MAAM,CAACC,QAAR,CAAnB,CADqE,CAErE;;AACA,UAAIF,MAAM,IAAI,IAAd,EAAoB;AACnB;AACAP,QAAAA,MAAM,CAACI,IAAP,CAAY,GAAGZ,MAAM,CAACW,OAAP,CAAeJ,IAAf,CAAf;AACA,OAHD,MAGO;AACN,YAAI,OAAOQ,MAAP,KAAkB,UAAtB,EAAkC;AACjC,gBAAM,IAAIhB,SAAJ,CAAc,+BAAd,CAAN;AACA,SAHK,CAKN;AACA;;;AACAS,QAAAA,MAAM,GAAG,CAAC,GAAGD,IAAJ,EACPM,GADO,CACHK,IAAI,IAAI;AACZ,cACC,OAAOA,IAAP,KAAgB,QAAhB,IAA4BzB,KAAK,CAACqB,gBAAN,CAAuBI,IAAvB,CAD7B,EAEE;AACD,kBAAM,IAAInB,SAAJ,CAAc,6CAAd,CAAN;AACA;;AAED,iBAAO,CAAC,GAAGmB,IAAJ,CAAP;AACA,SATO,EASLL,GATK,CASDK,IAAI,IAAI;AACd,cAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACtB,kBAAM,IAAIpB,SAAJ,CAAc,6CAAd,CAAN;AACA;;AAED,iBAAO,CAAC,GAAGmB,IAAJ,CAAP;AACA,SAfO,CAAT;AAgBA;AACD,KA9BM,MA8BA;AACN,YAAM,IAAInB,SAAJ,CAAc,yIAAd,CAAN;AACA,KA3CgB,CA6CjB;;;AACAS,IAAAA,MAAM,GACLA,MAAM,CAACW,MAAP,GAAgB,CAAhB,GACCX,MAAM,CAACK,GAAP,CAAW,CAAC,CAACjB,IAAD,EAAOM,KAAP,CAAD,KAAmB;AAC7BP,MAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACAO,MAAAA,mBAAmB,CAACP,IAAD,EAAOwB,MAAM,CAAClB,KAAD,CAAb,CAAnB;AACA,aAAO,CAACkB,MAAM,CAACxB,IAAD,CAAN,CAAayB,WAAb,EAAD,EAA6BD,MAAM,CAAClB,KAAD,CAAnC,CAAP;AACA,KAJD,CADD,GAMCoB,SAPF;AASA,UAAMd,MAAN,EAvDiB,CAyDjB;AACA;;AACA,WAAO,IAAIe,KAAJ,CAAU,IAAV,EAAgB;AACtBC,MAAAA,GAAG,CAACC,MAAD,EAASC,CAAT,EAAYC,QAAZ,EAAsB;AACxB,gBAAQD,CAAR;AACC,eAAK,QAAL;AACA,eAAK,KAAL;AACC,mBAAO,CAAC9B,IAAD,EAAOM,KAAP,KAAiB;AACvBP,cAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACAO,cAAAA,mBAAmB,CAACP,IAAD,EAAOwB,MAAM,CAAClB,KAAD,CAAb,CAAnB;AACA,qBAAOG,eAAe,CAACuB,SAAhB,CAA0BF,CAA1B,EAA6BG,IAA7B,CACNJ,MADM,EAENL,MAAM,CAACxB,IAAD,CAAN,CAAayB,WAAb,EAFM,EAGND,MAAM,CAAClB,KAAD,CAHA,CAAP;AAKA,aARD;;AAUD,eAAK,QAAL;AACA,eAAK,KAAL;AACA,eAAK,QAAL;AACC,mBAAON,IAAI,IAAI;AACdD,cAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACA,qBAAOS,eAAe,CAACuB,SAAhB,CAA0BF,CAA1B,EAA6BG,IAA7B,CACNJ,MADM,EAENL,MAAM,CAACxB,IAAD,CAAN,CAAayB,WAAb,EAFM,CAAP;AAIA,aAND;;AAQD,eAAK,MAAL;AACC,mBAAO,MAAM;AACZI,cAAAA,MAAM,CAACK,IAAP;AACA,qBAAO,IAAIC,GAAJ,CAAQ1B,eAAe,CAACuB,SAAhB,CAA0BI,IAA1B,CAA+BH,IAA/B,CAAoCJ,MAApC,CAAR,EAAqDO,IAArD,EAAP;AACA,aAHD;;AAKD;AACC,mBAAOC,OAAO,CAACT,GAAR,CAAYC,MAAZ,EAAoBC,CAApB,EAAuBC,QAAvB,CAAP;AA/BF;AAiCA;AACD;;;AApCsB,KAAhB,CAAP;AAsCA;;AAEsB,OAAlBX,MAAM,CAACkB,WAAW,IAAI;AAC1B,WAAO,KAAK5B,WAAL,CAAiBV,IAAxB;AACA;;AAEDuC,EAAAA,QAAQ,GAAG;AACV,WAAOnC,MAAM,CAAC4B,SAAP,CAAiBO,QAAjB,CAA0BN,IAA1B,CAA+B,IAA/B,CAAP;AACA;;AAEDL,EAAAA,GAAG,CAAC5B,IAAD,EAAO;AACT,UAAMc,MAAM,GAAG,KAAK0B,MAAL,CAAYxC,IAAZ,CAAf;;AACA,QAAIc,MAAM,CAACS,MAAP,KAAkB,CAAtB,EAAyB;AACxB,aAAO,IAAP;AACA;;AAED,QAAIjB,KAAK,GAAGQ,MAAM,CAAC2B,IAAP,CAAY,IAAZ,CAAZ;;AACA,QAAI,sBAAsBxC,IAAtB,CAA2BD,IAA3B,CAAJ,EAAsC;AACrCM,MAAAA,KAAK,GAAGA,KAAK,CAACmB,WAAN,EAAR;AACA;;AAED,WAAOnB,KAAP;AACA;;AAEDoC,EAAAA,OAAO,CAACC,QAAD,EAAWC,OAAO,GAAGlB,SAArB,EAAgC;AACtC,SAAK,MAAM1B,IAAX,IAAmB,KAAKoC,IAAL,EAAnB,EAAgC;AAC/BC,MAAAA,OAAO,CAACQ,KAAR,CAAcF,QAAd,EAAwBC,OAAxB,EAAiC,CAAC,KAAKhB,GAAL,CAAS5B,IAAT,CAAD,EAAiBA,IAAjB,EAAuB,IAAvB,CAAjC;AACA;AACD;;AAEO,GAANc,MAAM,GAAG;AACV,SAAK,MAAMd,IAAX,IAAmB,KAAKoC,IAAL,EAAnB,EAAgC;AAC/B,YAAM,KAAKR,GAAL,CAAS5B,IAAT,CAAN;AACA;AACD;AAED;AACD;AACA;;;AACU,GAAPe,OAAO,GAAG;AACX,SAAK,MAAMf,IAAX,IAAmB,KAAKoC,IAAL,EAAnB,EAAgC;AAC/B,YAAM,CAACpC,IAAD,EAAO,KAAK4B,GAAL,CAAS5B,IAAT,CAAP,CAAN;AACA;AACD;;AAEe,GAAfoB,MAAM,CAACC,QAAQ,IAAI;AACnB,WAAO,KAAKN,OAAL,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCF,EAAAA,GAAG,GAAG;AACL,WAAO,CAAC,GAAG,KAAKuB,IAAL,EAAJ,EAAiBU,MAAjB,CAAwB,CAAClC,MAAD,EAASmC,GAAT,KAAiB;AAC/CnC,MAAAA,MAAM,CAACmC,GAAD,CAAN,GAAc,KAAKP,MAAL,CAAYO,GAAZ,CAAd;AACA,aAAOnC,MAAP;AACA,KAHM,EAGJ,EAHI,CAAP;AAIA;AAED;AACD;AACA;;;AAC0C,GAAxCQ,MAAM,CAAC4B,GAAP,CAAW,4BAAX,CAAwC,IAAI;AAC5C,WAAO,CAAC,GAAG,KAAKZ,IAAL,EAAJ,EAAiBU,MAAjB,CAAwB,CAAClC,MAAD,EAASmC,GAAT,KAAiB;AAC/C,YAAMjC,MAAM,GAAG,KAAK0B,MAAL,CAAYO,GAAZ,CAAf,CAD+C,CAE/C;AACA;;AACA,UAAIA,GAAG,KAAK,MAAZ,EAAoB;AACnBnC,QAAAA,MAAM,CAACmC,GAAD,CAAN,GAAcjC,MAAM,CAAC,CAAD,CAApB;AACA,OAFD,MAEO;AACNF,QAAAA,MAAM,CAACmC,GAAD,CAAN,GAAcjC,MAAM,CAACS,MAAP,GAAgB,CAAhB,GAAoBT,MAApB,GAA6BA,MAAM,CAAC,CAAD,CAAjD;AACA;;AAED,aAAOF,MAAP;AACA,KAXM,EAWJ,EAXI,CAAP;AAYA;;AArLmD;AAwLrD;AACA;AACA;AACA;;AACAR,MAAM,CAAC6C,gBAAP,CACCzC,OAAO,CAACwB,SADT,EAEC,CAAC,KAAD,EAAQ,SAAR,EAAmB,SAAnB,EAA8B,QAA9B,EAAwCc,MAAxC,CAA+C,CAAClC,MAAD,EAASsC,QAAT,KAAsB;AACpEtC,EAAAA,MAAM,CAACsC,QAAD,CAAN,GAAmB;AAACC,IAAAA,UAAU,EAAE;AAAb,GAAnB;AACA,SAAOvC,MAAP;AACA,CAHD,EAGG,EAHH,CAFD;AAQA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASwC,cAAT,CAAwBC,OAAO,GAAG,EAAlC,EAAsC;AAC5C,SAAO,IAAI7C,OAAJ,CACN6C,OAAO,CACN;AADM,GAELP,MAFF,CAES,CAAClC,MAAD,EAASN,KAAT,EAAgBgD,KAAhB,EAAuBC,KAAvB,KAAiC;AACxC,QAAID,KAAK,GAAG,CAAR,KAAc,CAAlB,EAAqB;AACpB1C,MAAAA,MAAM,CAACI,IAAP,CAAYuC,KAAK,CAACC,KAAN,CAAYF,KAAZ,EAAmBA,KAAK,GAAG,CAA3B,CAAZ;AACA;;AAED,WAAO1C,MAAP;AACA,GARF,EAQI,EARJ,EASE6C,MATF,CASS,CAAC,CAACzD,IAAD,EAAOM,KAAP,CAAD,KAAmB;AAC1B,QAAI;AACHP,MAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACAO,MAAAA,mBAAmB,CAACP,IAAD,EAAOwB,MAAM,CAAClB,KAAD,CAAb,CAAnB;AACA,aAAO,IAAP;AACA,KAJD,CAIE,MAAM;AACP,aAAO,KAAP;AACA;AACD,GAjBF,CADM,CAAP;AAqBA","sourcesContent":["/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'util';\nimport http from 'http';\n\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* c8 ignore next */\n\t\t});\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n"]},"metadata":{},"sourceType":"module"}