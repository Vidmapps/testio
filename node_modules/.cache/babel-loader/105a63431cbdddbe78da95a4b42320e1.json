{"ast":null,"code":"// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\nimport './streams.cjs';\n/** @typedef {import('buffer').Blob} NodeBlob} */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\n\nconst POOL_SIZE = 65536;\n/** @param {(Blob | NodeBlob | Uint8Array)[]} parts */\n\nasync function* toIterator(parts, clone = true) {\n  for (let part of parts) {\n    if ('stream' in part) {\n      yield* part.stream();\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset;\n        let end = part.byteOffset + part.byteLength;\n\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE);\n          const chunk = part.buffer.slice(position, position + size);\n          position += chunk.byteLength;\n          yield new Uint8Array(chunk);\n        }\n      } else {\n        yield part;\n      }\n    } else {\n      /* c8 ignore start */\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0;\n\n      while (position !== part.size) {\n        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n      }\n      /* c8 ignore end */\n\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = [];\n  #type = '';\n  #size = 0;\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string }} [options]\n   */\n\n  constructor(blobParts = [], options = {}) {\n    let size = 0;\n    const parts = blobParts.map(element => {\n      let part;\n\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0));\n      } else if (element instanceof Blob) {\n        part = element;\n      } else {\n        part = new TextEncoder().encode(element);\n      }\n\n      size += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n      return part;\n    });\n    const type = options.type === undefined ? '' : String(options.type);\n    this.#type = /[^\\u0020-\\u007E]/.test(type) ? '' : type;\n    this.#size = size;\n    this.#parts = parts;\n  }\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n\n\n  get size() {\n    return this.#size;\n  }\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n\n\n  get type() {\n    return this.#type;\n  }\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n\n\n  async text() {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder();\n    let str = '';\n\n    for await (let part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, {\n        stream: true\n      });\n    } // Remaining\n\n\n    str += decoder.decode();\n    return str;\n  }\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  async arrayBuffer() {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n    const data = new Uint8Array(this.size);\n    let offset = 0;\n\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    return data.buffer;\n  }\n\n  stream() {\n    const it = toIterator(this.#parts, true);\n    return new ReadableStream({\n      type: 'bytes',\n\n      async pull(ctrl) {\n        const chunk = await it.next();\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n      }\n\n    });\n  }\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n\n\n  slice(start = 0, end = this.size, type = '') {\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const parts = this.#parts;\n    const blobParts = [];\n    let added = 0;\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break;\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        let chunk;\n\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.byteLength;\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.size;\n        }\n\n        blobParts.push(chunk);\n        relativeStart = 0; // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], {\n      type: String(type).toLowerCase()\n    });\n    blob.#size = span;\n    blob.#parts = blobParts;\n    return blob;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  static [Symbol.hasInstance](object) {\n    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n\n};\n\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n/** @type {typeof globalThis.Blob} */\n\nexport const Blob = _Blob;\nexport default Blob;","map":{"version":3,"sources":["/Users/vidmantasburba/Desktop/FrontEnd/frontend_oxylabs/testio/node_modules/fetch-blob/index.js"],"names":["POOL_SIZE","toIterator","parts","clone","part","stream","ArrayBuffer","isView","position","byteOffset","end","byteLength","size","Math","min","chunk","buffer","slice","Uint8Array","arrayBuffer","_Blob","Blob","type","constructor","blobParts","options","map","element","TextEncoder","encode","undefined","String","test","text","decoder","TextDecoder","str","decode","data","offset","set","length","it","ReadableStream","pull","ctrl","next","done","close","enqueue","value","start","relativeStart","max","relativeEnd","span","added","subarray","push","blob","toLowerCase","Symbol","toStringTag","hasInstance","object","Object","defineProperties","prototype","enumerable"],"mappings":"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","sourcesContent":["\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs';\n\n/** @typedef {import('buffer').Blob} NodeBlob} */\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n\n/** @param {(Blob | NodeBlob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n\tfor (let part of parts) {\n\t\tif ('stream' in part) {\n\t\t\tyield * part.stream();\n\t\t} else if (ArrayBuffer.isView(part)) {\n\t\t\tif (clone) {\n\t\t\t\tlet position = part.byteOffset;\n\t\t\t\tlet end = part.byteOffset + part.byteLength;\n\t\t\t\twhile (position !== end) {\n\t\t\t\t\tconst size = Math.min(end - position, POOL_SIZE);\n\t\t\t\t\tconst chunk = part.buffer.slice(position, position + size);\n\t\t\t\t\tposition += chunk.byteLength;\n\t\t\t\t\tyield new Uint8Array(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield part;\n\t\t\t}\n\t\t} else {\n\t\t\t/* c8 ignore start */\n\t\t\t// For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n\t\t\tlet position = 0;\n\t\t\twhile (position !== part.size) {\n\t\t\t\tconst chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));\n\t\t\t\tconst buffer = await chunk.arrayBuffer();\n\t\t\t\tposition += buffer.byteLength;\n\t\t\t\tyield new Uint8Array(buffer);\n\t\t\t}\n\t\t\t/* c8 ignore end */\n\t\t}\n\t}\n}\n\nconst _Blob = class Blob {\n\n\t/** @type {Array.<(Blob|Uint8Array)>} */\n\t#parts = [];\n\t#type = '';\n\t#size = 0;\n\n\t/**\n\t * The Blob() constructor returns a new Blob object. The content\n\t * of the blob consists of the concatenation of the values given\n\t * in the parameter array.\n\t *\n\t * @param {*} blobParts\n\t * @param {{ type?: string }} [options]\n\t */\n\tconstructor(blobParts = [], options = {}) {\n\t\tlet size = 0;\n\n\t\tconst parts = blobParts.map(element => {\n\t\t\tlet part;\n\t\t\tif (ArrayBuffer.isView(element)) {\n\t\t\t\tpart = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\tpart = new Uint8Array(element.slice(0));\n\t\t\t} else if (element instanceof Blob) {\n\t\t\t\tpart = element;\n\t\t\t} else {\n\t\t\t\tpart = new TextEncoder().encode(element);\n\t\t\t}\n\n\t\t\tsize += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\t\t\treturn part;\n\t\t});\n\n\t\tconst type = options.type === undefined ? '' : String(options.type);\n\n\t\tthis.#type = /[^\\u0020-\\u007E]/.test(type) ? '' : type;\n\t\tthis.#size = size;\n\t\tthis.#parts = parts;\n\t}\n\n\t/**\n\t * The Blob interface's size property returns the\n\t * size of the Blob in bytes.\n\t */\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t/**\n\t * The type property of a Blob object returns the MIME type of the file.\n\t */\n\tget type() {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * The text() method in the Blob interface returns a Promise\n\t * that resolves with a string containing the contents of\n\t * the blob, interpreted as UTF-8.\n\t *\n\t * @return {Promise<string>}\n\t */\n\tasync text() {\n\t\t// More optimized than using this.arrayBuffer()\n\t\t// that requires twice as much ram\n\t\tconst decoder = new TextDecoder();\n\t\tlet str = '';\n\t\tfor await (let part of toIterator(this.#parts, false)) {\n\t\t\tstr += decoder.decode(part, { stream: true });\n\t\t}\n\t\t// Remaining\n\t\tstr += decoder.decode();\n\t\treturn str;\n\t}\n\n\t/**\n\t * The arrayBuffer() method in the Blob interface returns a\n\t * Promise that resolves with the contents of the blob as\n\t * binary data contained in an ArrayBuffer.\n\t *\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tasync arrayBuffer() {\n\t\t// Easier way... Just a unnecessary overhead\n\t\t// const view = new Uint8Array(this.size);\n\t\t// await this.stream().getReader({mode: 'byob'}).read(view);\n\t\t// return view.buffer;\n\n\t\tconst data = new Uint8Array(this.size);\n\t\tlet offset = 0;\n\t\tfor await (const chunk of toIterator(this.#parts, false)) {\n\t\t\tdata.set(chunk, offset);\n\t\t\toffset += chunk.length;\n\t\t}\n\n\t\treturn data.buffer;\n\t}\n\n\tstream() {\n\t\tconst it = toIterator(this.#parts, true);\n\n\t\treturn new ReadableStream({\n\t\t\ttype: 'bytes',\n\t\t\tasync pull(ctrl) {\n\t\t\t\tconst chunk = await it.next();\n\t\t\t\tchunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * The Blob interface's slice() method creates and returns a\n\t * new Blob object which contains data from a subset of the\n\t * blob on which it's called.\n\t *\n\t * @param {number} [start]\n\t * @param {number} [end]\n\t * @param {string} [type]\n\t */\n\tslice(start = 0, end = this.size, type = '') {\n\t\tconst {size} = this;\n\n\t\tlet relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n\t\tlet relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\t\tconst parts = this.#parts;\n\t\tconst blobParts = [];\n\t\tlet added = 0;\n\n\t\tfor (const part of parts) {\n\t\t\t// don't add the overflow to new blobParts\n\t\t\tif (added >= span) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\t\t\tif (relativeStart && size <= relativeStart) {\n\t\t\t\t// Skip the beginning and change the relative\n\t\t\t\t// start & end position as we skip the unwanted parts\n\t\t\t\trelativeStart -= size;\n\t\t\t\trelativeEnd -= size;\n\t\t\t} else {\n\t\t\t\tlet chunk\n\t\t\t\tif (ArrayBuffer.isView(part)) {\n\t\t\t\t\tchunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n\t\t\t\t\tadded += chunk.byteLength\n\t\t\t\t} else {\n\t\t\t\t\tchunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n\t\t\t\t\tadded += chunk.size\n\t\t\t\t}\n\t\t\t\tblobParts.push(chunk);\n\t\t\t\trelativeStart = 0; // All next sequential parts should start at 0\n\t\t\t}\n\t\t}\n\n\t\tconst blob = new Blob([], {type: String(type).toLowerCase()});\n\t\tblob.#size = span;\n\t\tblob.#parts = blobParts;\n\n\t\treturn blob;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Blob';\n\t}\n\n\tstatic [Symbol.hasInstance](object) {\n\t\treturn (\n\t\t\tobject &&\n\t\t\ttypeof object === 'object' &&\n\t\t\ttypeof object.constructor === 'function' &&\n\t\t\t(\n\t\t\t\ttypeof object.stream === 'function' ||\n\t\t\t\ttypeof object.arrayBuffer === 'function'\n\t\t\t) &&\n\t\t\t/^(Blob|File)$/.test(object[Symbol.toStringTag])\n\t\t);\n\t}\n}\n\nObject.defineProperties(_Blob.prototype, {\n\tsize: {enumerable: true},\n\ttype: {enumerable: true},\n\tslice: {enumerable: true}\n});\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob;\nexport default Blob;\n"]},"metadata":{},"sourceType":"module"}