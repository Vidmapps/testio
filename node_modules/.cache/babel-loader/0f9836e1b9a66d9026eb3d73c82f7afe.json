{"ast":null,"code":"/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'stream';\nimport { types } from 'util';\nimport Blob from 'fetch-blob';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { formDataIterator, getBoundary, getFormDataLength } from './utils/form-data.js';\nimport { isBlob, isURLSearchParameters, isFormData } from './utils/is.js';\nconst INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexport default class Body {\n  constructor(body, {\n    size = 0\n  } = {}) {\n    let boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (isFormData(body)) {\n      // Body is an instance of formdata-node\n      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;\n      body = Stream.Readable.from(formDataIterator(body, boundary));\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    this[INTERNALS] = {\n      body,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].body;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n\n\n  async arrayBuffer() {\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n\n\n  async blob() {\n    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n    const buf = await this.buffer();\n    return new Blob([buf], {\n      type: ct\n    });\n  }\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n\n\n  async json() {\n    const buffer = await consumeBody(this);\n    return JSON.parse(buffer.toString());\n  }\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n\n\n  async text() {\n    const buffer = await consumeBody(this);\n    return buffer.toString();\n  }\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n\n\n  buffer() {\n    return consumeBody(this);\n  }\n\n} // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n\n  data[INTERNALS].disturbed = true;\n\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n\n  let {\n    body\n  } = data; // Body is null\n\n  if (body === null) {\n    return Buffer.alloc(0);\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    body = Stream.Readable.from(body.stream());\n  } // Body is buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body;\n  }\n  /* c8 ignore next 3 */\n\n\n  if (!(body instanceof Stream)) {\n    return Buffer.alloc(0);\n  } // Body is stream\n  // get ready to actually consume the body\n\n\n  const accum = [];\n  let accumBytes = 0;\n\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n        body.destroy(error);\n        throw error;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n    throw error_;\n  }\n\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every(c => typeof c === 'string')) {\n        return Buffer.from(accum.join(''));\n      }\n\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].body = p1;\n    body = p2;\n  }\n\n  return body;\n};\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  }\n\n  if (isFormData(body)) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is a spec-compliant form-data\n\n\n  if (isFormData(body)) {\n    return getFormDataLength(request[INTERNALS].boundary);\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\n\nexport const writeToStream = (dest, {\n  body\n}) => {\n  if (body === null) {\n    // Body is null\n    dest.end();\n  } else if (isBlob(body)) {\n    // Body is Blob\n    Stream.Readable.from(body.stream()).pipe(dest);\n  } else if (Buffer.isBuffer(body)) {\n    // Body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // Body is stream\n    body.pipe(dest);\n  }\n};","map":{"version":3,"sources":["/Users/vidmantasburba/Desktop/FrontEnd/frontend_oxylabs/testio/node_modules/node-fetch/src/body.js"],"names":["Stream","PassThrough","types","Blob","FetchError","FetchBaseError","formDataIterator","getBoundary","getFormDataLength","isBlob","isURLSearchParameters","isFormData","INTERNALS","Symbol","Body","constructor","body","size","boundary","Buffer","from","toString","isBuffer","isAnyArrayBuffer","ArrayBuffer","isView","buffer","byteOffset","byteLength","Readable","String","disturbed","error","on","error_","url","message","bodyUsed","arrayBuffer","consumeBody","slice","blob","ct","headers","get","type","buf","json","JSON","parse","text","Object","defineProperties","prototype","enumerable","data","TypeError","alloc","stream","accum","accumBytes","chunk","length","destroy","push","readableEnded","_readableState","ended","every","c","join","concat","clone","instance","highWaterMark","p1","p2","Error","pipe","extractContentType","request","getTotalBytes","getLengthSync","hasKnownLength","writeToStream","dest","end","write"],"mappings":"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","sourcesContent":["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'stream';\nimport {types} from 'util';\n\nimport Blob from 'fetch-blob';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {formDataIterator, getBoundary, getFormDataLength} from './utils/form-data.js';\nimport {isBlob, isURLSearchParameters, isFormData} from './utils/is.js';\n\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (isFormData(body)) {\n\t\t\t// Body is an instance of formdata-node\n\t\t\tboundary = `NodeFetchFormDataBoundary${getBoundary()}`;\n\t\t\tbody = Stream.Readable.from(formDataIterator(body, boundary));\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.buffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn JSON.parse(buffer.toString());\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tlet {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\tbody = Stream.Readable.from(body.stream());\n\t}\n\n\t// Body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body;\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance;\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t}\n\n\tif (isFormData(body)) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request;\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is a spec-compliant form-data\n\tif (isFormData(body)) {\n\t\treturn getFormDataLength(request[INTERNALS].boundary);\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\nexport const writeToStream = (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\t// Body is Blob\n\t\tStream.Readable.from(body.stream()).pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// Body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tbody.pipe(dest);\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}