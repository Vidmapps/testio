{"ast":null,"code":"import { randomBytes } from 'crypto';\nimport { isBlob } from './is.js';\nconst carriage = '\\r\\n';\nconst dashes = '-'.repeat(2);\nconst carriageLength = Buffer.byteLength(carriage);\n/**\n * @param {string} boundary\n */\n\nconst getFooter = boundary => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;\n/**\n * @param {string} boundary\n * @param {string} name\n * @param {*} field\n *\n * @return {string}\n */\n\n\nfunction getHeader(boundary, name, field) {\n  let header = '';\n  header += `${dashes}${boundary}${carriage}`;\n  header += `Content-Disposition: form-data; name=\"${name}\"`;\n\n  if (isBlob(field)) {\n    header += `; filename=\"${field.name}\"${carriage}`;\n    header += `Content-Type: ${field.type || 'application/octet-stream'}`;\n  }\n\n  return `${header}${carriage.repeat(2)}`;\n}\n/**\n * @return {string}\n */\n\n\nexport const getBoundary = () => randomBytes(8).toString('hex');\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\n\nexport async function* formDataIterator(form, boundary) {\n  for (const [name, value] of form) {\n    yield getHeader(boundary, name, value);\n\n    if (isBlob(value)) {\n      yield* value.stream();\n    } else {\n      yield value;\n    }\n\n    yield carriage;\n  }\n\n  yield getFooter(boundary);\n}\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\n\nexport function getFormDataLength(form, boundary) {\n  let length = 0;\n\n  for (const [name, value] of form) {\n    length += Buffer.byteLength(getHeader(boundary, name, value));\n    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));\n    length += carriageLength;\n  }\n\n  length += Buffer.byteLength(getFooter(boundary));\n  return length;\n}","map":{"version":3,"sources":["/Users/vidmantasburba/Desktop/FrontEnd/frontend_oxylabs/testio/node_modules/node-fetch/src/utils/form-data.js"],"names":["randomBytes","isBlob","carriage","dashes","repeat","carriageLength","Buffer","byteLength","getFooter","boundary","getHeader","name","field","header","type","getBoundary","toString","formDataIterator","form","value","stream","getFormDataLength","length","size","String"],"mappings":"AAAA,SAAQA,WAAR,QAA0B,QAA1B;AAEA,SAAQC,MAAR,QAAqB,SAArB;AAEA,MAAMC,QAAQ,GAAG,MAAjB;AACA,MAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAW,CAAX,CAAf;AACA,MAAMC,cAAc,GAAGC,MAAM,CAACC,UAAP,CAAkBL,QAAlB,CAAvB;AAEA;AACA;AACA;;AACA,MAAMM,SAAS,GAAGC,QAAQ,IAAK,GAAEN,MAAO,GAAEM,QAAS,GAAEN,MAAO,GAAED,QAAQ,CAACE,MAAT,CAAgB,CAAhB,CAAmB,EAAjF;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,SAAT,CAAmBD,QAAnB,EAA6BE,IAA7B,EAAmCC,KAAnC,EAA0C;AACzC,MAAIC,MAAM,GAAG,EAAb;AAEAA,EAAAA,MAAM,IAAK,GAAEV,MAAO,GAAEM,QAAS,GAAEP,QAAS,EAA1C;AACAW,EAAAA,MAAM,IAAK,yCAAwCF,IAAK,GAAxD;;AAEA,MAAIV,MAAM,CAACW,KAAD,CAAV,EAAmB;AAClBC,IAAAA,MAAM,IAAK,eAAcD,KAAK,CAACD,IAAK,IAAGT,QAAS,EAAhD;AACAW,IAAAA,MAAM,IAAK,iBAAgBD,KAAK,CAACE,IAAN,IAAc,0BAA2B,EAApE;AACA;;AAED,SAAQ,GAAED,MAAO,GAAEX,QAAQ,CAACE,MAAT,CAAgB,CAAhB,CAAmB,EAAtC;AACA;AAED;AACA;AACA;;;AACA,OAAO,MAAMW,WAAW,GAAG,MAAMf,WAAW,CAAC,CAAD,CAAX,CAAegB,QAAf,CAAwB,KAAxB,CAA1B;AAEP;AACA;AACA;AACA;;AACA,OAAO,gBAAiBC,gBAAjB,CAAkCC,IAAlC,EAAwCT,QAAxC,EAAkD;AACxD,OAAK,MAAM,CAACE,IAAD,EAAOQ,KAAP,CAAX,IAA4BD,IAA5B,EAAkC;AACjC,UAAMR,SAAS,CAACD,QAAD,EAAWE,IAAX,EAAiBQ,KAAjB,CAAf;;AAEA,QAAIlB,MAAM,CAACkB,KAAD,CAAV,EAAmB;AAClB,aAAQA,KAAK,CAACC,MAAN,EAAR;AACA,KAFD,MAEO;AACN,YAAMD,KAAN;AACA;;AAED,UAAMjB,QAAN;AACA;;AAED,QAAMM,SAAS,CAACC,QAAD,CAAf;AACA;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASY,iBAAT,CAA2BH,IAA3B,EAAiCT,QAAjC,EAA2C;AACjD,MAAIa,MAAM,GAAG,CAAb;;AAEA,OAAK,MAAM,CAACX,IAAD,EAAOQ,KAAP,CAAX,IAA4BD,IAA5B,EAAkC;AACjCI,IAAAA,MAAM,IAAIhB,MAAM,CAACC,UAAP,CAAkBG,SAAS,CAACD,QAAD,EAAWE,IAAX,EAAiBQ,KAAjB,CAA3B,CAAV;AAEAG,IAAAA,MAAM,IAAIrB,MAAM,CAACkB,KAAD,CAAN,GAAgBA,KAAK,CAACI,IAAtB,GAA6BjB,MAAM,CAACC,UAAP,CAAkBiB,MAAM,CAACL,KAAD,CAAxB,CAAvC;AAEAG,IAAAA,MAAM,IAAIjB,cAAV;AACA;;AAEDiB,EAAAA,MAAM,IAAIhB,MAAM,CAACC,UAAP,CAAkBC,SAAS,CAACC,QAAD,CAA3B,CAAV;AAEA,SAAOa,MAAP;AACA","sourcesContent":["import {randomBytes} from 'crypto';\n\nimport {isBlob} from './is.js';\n\nconst carriage = '\\r\\n';\nconst dashes = '-'.repeat(2);\nconst carriageLength = Buffer.byteLength(carriage);\n\n/**\n * @param {string} boundary\n */\nconst getFooter = boundary => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;\n\n/**\n * @param {string} boundary\n * @param {string} name\n * @param {*} field\n *\n * @return {string}\n */\nfunction getHeader(boundary, name, field) {\n\tlet header = '';\n\n\theader += `${dashes}${boundary}${carriage}`;\n\theader += `Content-Disposition: form-data; name=\"${name}\"`;\n\n\tif (isBlob(field)) {\n\t\theader += `; filename=\"${field.name}\"${carriage}`;\n\t\theader += `Content-Type: ${field.type || 'application/octet-stream'}`;\n\t}\n\n\treturn `${header}${carriage.repeat(2)}`;\n}\n\n/**\n * @return {string}\n */\nexport const getBoundary = () => randomBytes(8).toString('hex');\n\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\nexport async function * formDataIterator(form, boundary) {\n\tfor (const [name, value] of form) {\n\t\tyield getHeader(boundary, name, value);\n\n\t\tif (isBlob(value)) {\n\t\t\tyield * value.stream();\n\t\t} else {\n\t\t\tyield value;\n\t\t}\n\n\t\tyield carriage;\n\t}\n\n\tyield getFooter(boundary);\n}\n\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\nexport function getFormDataLength(form, boundary) {\n\tlet length = 0;\n\n\tfor (const [name, value] of form) {\n\t\tlength += Buffer.byteLength(getHeader(boundary, name, value));\n\n\t\tlength += isBlob(value) ? value.size : Buffer.byteLength(String(value));\n\n\t\tlength += carriageLength;\n\t}\n\n\tlength += Buffer.byteLength(getFooter(boundary));\n\n\treturn length;\n}\n"]},"metadata":{},"sourceType":"module"}